"""
Main window implementation for Album Explorer.

TODO Phase 7.1: View Integration
- Integrate ViewManager for visualization management
- Implement Network, Chord, and Arc views
- Add view transition controls
- Implement view switching UI

TODO Phase 7.2: Error Handling
- Integrate ErrorManager for error handling
- Add error feedback UI components
- Implement error recovery hints
- Add error state management

TODO Phase 7.3: Responsive Design
- Integrate ResponsiveManager
- Implement dynamic layout adjustments
- Add screen size adaptations
- Implement component scaling

TODO Phase 7.4: View Synchronization
- Implement cross-view selection sync
- Add shared state management
- Integrate ViewIntegrationManager
- Implement real-time view updates
"""

import logging
from pathlib import Path
from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
						   QLabel, QComboBox, QStatusBar, QPushButton, QFrame)
from albumexplore.visualization.error_handling import ErrorCategory, ErrorSeverity, ErrorContext, ErrorInfo
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QResizeEvent, QScreen

from albumexplore.data.parsers.csv_parser import CSVParser
from albumexplore.visualization.view_manager import ViewManager
from albumexplore.visualization.data_interface import DataInterface
from albumexplore.visualization.error_handling import ErrorManager, ErrorCategory, ErrorContext
from albumexplore.visualization.responsive import ResponsiveManager
from albumexplore.visualization.state import ViewType
from albumexplore.visualization.view_integration import ViewIntegrationManager, TransitionType
from albumexplore.visualization.views import create_view

logging.basicConfig(level=logging.INFO)


class MainWindow(QMainWindow):
	def __init__(self):
		super().__init__()
		logging.info("Initializing Album Explorer main window")
		
		# Initialize managers
		self.data_interface = DataInterface()
		self.view_manager = ViewManager(self.data_interface)
		self.error_manager = ErrorManager()
		self.responsive_manager = ResponsiveManager()
		
		self.setWindowTitle("Album Explorer")
		self.setMinimumSize(1200, 800)
		
		# Create central widget and layout
		central_widget = QWidget()
		self.setCentralWidget(central_widget)
		self.main_layout = QVBoxLayout(central_widget)
		
		# Setup error handling first
		self._setup_error_handling()
		
		# Initialize responsive design
		self._setup_responsive_design()
		
		# Create central widget and layout
		central_widget = QWidget()
		self.setCentralWidget(central_widget)
		self.main_layout = QVBoxLayout(central_widget)
		
		# Create view controls
		self._create_view_controls()
		
		# Create view container
		self.view_container = QWidget()
		self.view_layout = QVBoxLayout(self.view_container)
		self.main_layout.addWidget(self.view_container)
		
		# Initialize with table view
		self._initialize_view(ViewType.TABLE)
		
		# Create status bar
		self.status_bar = QStatusBar()
		self.setStatusBar(self.status_bar)
		
		# Setup error handling
		self._setup_error_handling()
		
		# Load data
		self.load_data()

	
	def _create_view_controls(self):
		"""Create view type selection and transition controls."""
		controls = QHBoxLayout()
		
		# View type selector
		view_label = QLabel("View Type:")
		self.view_selector = QComboBox()
		self.view_selector.addItems([vt.value for vt in ViewType])
		self.view_selector.currentTextChanged.connect(self._handle_view_change)
		
		# Transition type selector
		transition_label = QLabel("Transition:")
		self.transition_selector = QComboBox()
		self.transition_selector.addItems([t.value for t in TransitionType])
		
		controls.addWidget(view_label)
		controls.addWidget(self.view_selector)
		controls.addWidget(transition_label)
		controls.addWidget(self.transition_selector)
		controls.addStretch()
		
		self.main_layout.addLayout(controls)
	
	def _initialize_view(self, view_type: ViewType):
		"""Initialize view with specified type."""
		try:
			# Create view through ViewManager
			result = self.view_manager.switch_view(view_type)
			
			# Create the view widget
			self.current_view = create_view(view_type, self)
			self.current_view.selectionChanged.connect(self._handle_selection_change)
			
			# Apply any transition data
			if 'transition' in result:
				self.current_view.apply_transition(result['transition'])
			
			# Update view with data
			self.current_view.update_data(
				self.view_manager.nodes,
				self.view_manager.edges
			)
			
			# Add to layout
			self.view_layout.addWidget(self.current_view)
			
		except Exception as e:
			self.error_manager.handle_error(e, ErrorContext(
				view_type=str(view_type),
				operation="view_initialization",
				data={}
			))

	def _handle_view_change(self, view_type_str: str):
		"""Handle view type change."""
		try:
			view_type = ViewType(view_type_str)
			
			# Get result from ViewManager
			result = self.view_manager.switch_view(view_type)
			
			# Create new view
			new_view = create_view(view_type, self)
			new_view.selectionChanged.connect(self._handle_selection_change)
			
			# Apply transition if specified
			if 'transition' in result:
				new_view.apply_transition(result['transition'])
			
			# Update view with data
			new_view.update_data(
				self.view_manager.nodes,
				self.view_manager.edges
			)
			
			# Replace current view
			old_view = self.current_view
			self.view_layout.replaceWidget(old_view, new_view)
			old_view.deleteLater()
			self.current_view = new_view
			
		except Exception as e:
			self.error_manager.handle_error(e, ErrorContext(
				view_type=view_type_str,
				operation="view_switch",
				data={}
			))
	
	def _handle_selection_change(self, selected_ids: set):
		"""Handle selection change in current view."""
		result = self.view_manager.select_nodes(selected_ids)
		self.current_view.update_data(
			self.view_manager.nodes,
			self.view_manager.edges
		)
	
	def _create_error_display(self):
		"""Create error display widget."""
		self.error_frame = QFrame()
		self.error_frame.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
		self.error_frame.setStyleSheet("QFrame { background-color: #ffebee; }")
		self.error_frame.hide()
		
		error_layout = QVBoxLayout(self.error_frame)
		
		# Error message label
		self.error_message = QLabel()
		self.error_message.setStyleSheet("QLabel { color: #c62828; }")
		error_layout.addWidget(self.error_message)
		
		# Recovery hint label
		self.recovery_hint = QLabel()
		self.recovery_hint.setStyleSheet("QLabel { color: #2e7d32; }")
		error_layout.addWidget(self.recovery_hint)
		
		# Dismiss button
		dismiss_button = QPushButton("Dismiss")
		dismiss_button.clicked.connect(self._dismiss_error)
		error_layout.addWidget(dismiss_button)
		
		# Add to main layout before view container
		self.main_layout.insertWidget(1, self.error_frame)

	def _setup_error_handling(self):
		"""Setup error handling for the application."""
		self._create_error_display()
		
		def handle_error(error_info: ErrorInfo):
			# Update error display
			self.error_message.setText(f"Error: {error_info.message}")
			self.recovery_hint.setText(f"Recovery: {error_info.recovery_hint}")
			self.error_frame.show()
			
			# Show in status bar for less severe errors
			if error_info.severity != ErrorSeverity.CRITICAL:
				self.status_bar.showMessage(
					f"Error: {error_info.message} - {error_info.recovery_hint}",
					5000
				)
		
		# Register handlers for different categories
		for category in ErrorCategory:
			self.error_manager.register_handler(category, handle_error)

	def _dismiss_error(self):
		"""Dismiss current error display."""
		self.error_frame.hide()
		self.error_manager.clear_errors()
	
	def load_data(self):
		"""Load data and initialize views."""
		try:
			csv_dir = Path("/home/seth-n/PycharmProjects/AlbumExplore/csv")
			logging.info(f"Looking for CSV files in: {csv_dir}")
			if not csv_dir.exists():
				msg = f"CSV directory not found: {csv_dir}"
				logging.error(msg)
				self.status_bar.showMessage(msg)
				return
			
			logging.info("Creating CSVParser...")
			parser = CSVParser(csv_dir)
			logging.info("Parsing CSV files...")
			df = parser.parse()
			
			if df.empty:
				msg = "No data parsed from CSV files"
				logging.error(msg)
				self.status_bar.showMessage(msg)
				return
			
			# Update data interface
			self.data_interface.update_data(df)
			
			# Initialize view with data
			self.view_manager.update_data()
			if hasattr(self, 'current_view'):
				self.current_view.update_data(
					self.view_manager.nodes,
					self.view_manager.edges
				)
			
			msg = f"Loaded {len(df)} albums"
			logging.info(msg)
			self.status_bar.showMessage(msg)
			
		except Exception as e:
			msg = f"Error loading data: {str(e)}"
			logging.error(msg, exc_info=True)
			self.status_bar.showMessage(msg)

	
	def _setup_responsive_design(self):
		"""Initialize responsive design features."""
		self.responsive_manager.set_base_window_size(QSize(1200, 800))
		self.responsive_manager.set_min_window_size(QSize(800, 600))
		self.responsive_manager.set_max_window_size(QSize(3840, 2160))
		
		# Register components for scaling
		self.responsive_manager.register_component(self.view_container, "view_container")
		self.responsive_manager.register_component(self.status_bar, "status_bar")
		
		# Set initial scale factors
		self._update_scale_factors()

	def _update_scale_factors(self):
		"""Update scale factors based on current window size."""
		window_size = self.size()
		base_size = self.responsive_manager.get_base_window_size()
		
		# Calculate scale factors
		width_scale = window_size.width() / base_size.width()
		height_scale = window_size.height() / base_size.height()
		
		# Update component sizes
		self.responsive_manager.update_scale_factors(width_scale, height_scale)
		self._apply_responsive_layout()

	def _apply_responsive_layout(self):
		"""Apply responsive layout adjustments."""
		window_width = self.width()
		
		# Adjust layout based on window width
		if window_width < 1000:
			# Compact layout
			self.main_layout.setSpacing(5)
			self.view_layout.setSpacing(5)
			self._adjust_compact_layout()
		elif window_width < 1400:
			# Medium layout
			self.main_layout.setSpacing(10)
			self.view_layout.setSpacing(10)
			self._adjust_medium_layout()
		else:
			# Full layout
			self.main_layout.setSpacing(15)
			self.view_layout.setSpacing(15)
			self._adjust_full_layout()

	def _adjust_compact_layout(self):
		"""Adjust layout for compact view."""
		# Adjust component sizes for compact view
		self.view_container.setMinimumHeight(400)
		if hasattr(self, 'view_selector'):
			self.view_selector.setMaximumWidth(150)
		if hasattr(self, 'transition_selector'):
			self.transition_selector.setMaximumWidth(150)

	def _adjust_medium_layout(self):
		"""Adjust layout for medium view."""
		# Adjust component sizes for medium view
		self.view_container.setMinimumHeight(500)
		if hasattr(self, 'view_selector'):
			self.view_selector.setMaximumWidth(200)
		if hasattr(self, 'transition_selector'):
			self.transition_selector.setMaximumWidth(200)

	def _adjust_full_layout(self):
		"""Adjust layout for full view."""
		# Adjust component sizes for full view
		self.view_container.setMinimumHeight(600)
		if hasattr(self, 'view_selector'):
			self.view_selector.setMaximumWidth(250)
		if hasattr(self, 'transition_selector'):
			self.transition_selector.setMaximumWidth(250)

	def resizeEvent(self, event: QResizeEvent):
		"""Handle window resize event."""
		super().resizeEvent(event)
		
		# Update responsive layout
		self._update_scale_factors()
		
		# Update view if exists
		if hasattr(self, 'current_view'):
			result = self.view_manager.update_dimensions(
				event.size().width(),
				event.size().height()
			)
			self.current_view.update_data(
				self.view_manager.nodes,
				self.view_manager.edges
			)
	def __init__(self, db_session):
		super().__init__()
		logging.info("Initializing Album Explorer main window")
		
		# Initialize managers
		self.data_interface = DataInterface(db_session)
		self.view_manager = ViewManager(self.data_interface)
		self.error_manager = ErrorManager()
		self.responsive_manager = ResponsiveManager()
		
		self.setWindowTitle("Album Explorer")
		self.setMinimumSize(1200, 800)
		
		# Setup error handling first
		self._setup_error_handling()
		
		# Initialize responsive design
		self._setup_responsive_design()
		
		# Create central widget and layout
		central_widget = QWidget()
		self.setCentralWidget(central_widget)
		self.main_layout = QVBoxLayout(central_widget)
		
		# Create view controls
		self._create_view_controls()
		
		# Create view container
		self.view_container = QWidget()
		self.view_layout = QVBoxLayout(self.view_container)
		self.main_layout.addWidget(self.view_container)
		
		# Initialize with table view
		self._initialize_view(ViewType.TABLE)
		
		# Create status bar
		self.status_bar = QStatusBar()
		self.setStatusBar(self.status_bar)
		
		# Load data
		self.load_data()



	def _create_albums_tab(self):
		widget = QWidget()
		layout = QVBoxLayout(widget)
		
		# Search controls
		search_layout = QHBoxLayout()
		search_label = QLabel("Search:")
		self.search_input = QLineEdit()
		self.search_type = QComboBox()
		self.search_type.addItems(["Artist", "Album", "Genre", "Country"])
		search_button = QPushButton("Search")
		search_button.clicked.connect(self.search_albums)
		
		search_layout.addWidget(search_label)
		search_layout.addWidget(self.search_input)
		search_layout.addWidget(self.search_type)
		search_layout.addWidget(search_button)
		layout.addLayout(search_layout)
		
		# Results table
		self.albums_table = QTableWidget()
		self.albums_table.setColumnCount(6)
		self.albums_table.setHorizontalHeaderLabels(
			["Artist", "Album", "Release Date", "Genre/Subgenres", "Vocal Style", "Country"]
		)
		# Connect header click without enabling built-in sorting
		self.albums_table.horizontalHeader().sectionClicked.connect(self.handle_header_click)
		self.current_sort_column = None
		self.sort_order = Qt.SortOrder.AscendingOrder
		layout.addWidget(self.albums_table)
		
		return widget


	def _create_tags_tab(self):
		widget = QWidget()
		layout = QVBoxLayout(widget)
		
		# Tag list with sorting enabled
		self.tags_table = QTableWidget()
		self.tags_table.setColumnCount(2)
		self.tags_table.setHorizontalHeaderLabels(["Tag", "Frequency"])
		self.tags_table.setSortingEnabled(True)
		self.tags_table.horizontalHeader().sectionClicked.connect(self.handle_tags_header_click)
		self.tags_sort_column = 0
		self.tags_sort_order = Qt.SortOrder.AscendingOrder
		layout.addWidget(self.tags_table)
		
		return widget

	def _create_relationships_tab(self):
		widget = QWidget()
		layout = QVBoxLayout(widget)
		
		# Tag selection
		select_layout = QHBoxLayout()
		select_label = QLabel("Select Tag:")
		self.tag_select = QComboBox()
		self.tag_select.currentTextChanged.connect(self.update_relationships)
		select_layout.addWidget(select_label)
		select_layout.addWidget(self.tag_select)
		layout.addLayout(select_layout)
		
		# Relationships table with sorting enabled
		self.relationships_table = QTableWidget()
		self.relationships_table.setColumnCount(2)
		self.relationships_table.setHorizontalHeaderLabels(["Related Tag", "Strength"])
		self.relationships_table.setSortingEnabled(True)
		self.relationships_table.horizontalHeader().sectionClicked.connect(self.handle_relationships_header_click)
		self.relationships_sort_column = 0
		self.relationships_sort_order = Qt.SortOrder.AscendingOrder
		layout.addWidget(self.relationships_table)
		
		return widget


	def load_data(self):
		try:
			csv_dir = Path("/home/seth-n/PycharmProjects/AlbumExplore/csv")
			logging.info(f"Looking for CSV files in: {csv_dir}")
			if not csv_dir.exists():
				msg = f"CSV directory not found: {csv_dir}"
				logging.error(msg)
				self.status_bar.showMessage(msg)
				return
			
			logging.info("Creating CSVParser...")
			parser = CSVParser(csv_dir)
			logging.info("Parsing CSV files...")
			self.df = parser.parse()
			
			if self.df.empty:
				msg = "No data parsed from CSV files"
				logging.error(msg)
				self.status_bar.showMessage(msg)
				return
			
			logging.info(f"Successfully loaded {len(self.df)} rows of data")
			
			# Extract tags
			logging.info("Extracting tags...")
			for tags in self.df['tags']:
				if isinstance(tags, list):
					self.all_tags.update(tags)
			
			# Update tag comboboxes
			sorted_tags = sorted(self.all_tags)
			self.tag_select.addItems(sorted_tags)
			self.consolidation_tag_select.addItems(sorted_tags)
			
			# Update tables
			logging.info("Updating tables...")
			self.update_albums_table()
			self.update_tags_table()
			self.update_consolidation_table()
			
			msg = f"Loaded {len(self.df)} albums with {len(self.all_tags)} unique tags"
			logging.info(msg)
			self.status_bar.showMessage(msg)
			
		except Exception as e:
			msg = f"Error loading data: {str(e)}"
			logging.error(msg, exc_info=True)
			self.status_bar.showMessage(msg)

	def search_albums(self):
		search_text = self.search_input.text().lower()
		search_type = self.search_type.currentText()
		
		if search_text:
			if search_type == "Genre":
				matches = self.df[self.df['tags'].apply(
					lambda x: any(search_text in tag.lower() for tag in x)
				)]
			else:
				column = search_type if search_type != "Genre" else "Genre / Subgenres"
				matches = self.df[
					self.df[column].str.lower().str.contains(search_text, na=False)
				]
			
			self.update_albums_table(matches)
			self.status_bar.showMessage(f"Found {len(matches)} matching albums")
		else:
			self.update_albums_table()

	def handle_header_click(self, column):
		"""Handle table header click for sorting."""
		if column == self.current_sort_column:
			self.sort_order = Qt.SortOrder.DescendingOrder if self.sort_order == Qt.SortOrder.AscendingOrder else Qt.SortOrder.AscendingOrder
		else:
			self.sort_order = Qt.SortOrder.AscendingOrder
			self.current_sort_column = column
		
		self._sort_table(column)

	def _sort_table(self, column):
		"""Sort table by column with missing values at bottom."""
		rows = []
		for row in range(self.albums_table.rowCount()):
			items = []
			for col in range(self.albums_table.columnCount()):
				item = self.albums_table.item(row, col)
				items.append(item.clone() if item else QTableWidgetItem(""))
			rows.append(items)
		
		# Sort rows
		def sort_key(row_items):
			value = row_items[column].text().strip()
			# Empty values sort to bottom
			if not value:
				return (1, "")
			# Normal sort for non-empty values
			return (0, value.lower())
		
		rows.sort(
			key=sort_key,
			reverse=self.sort_order == Qt.SortOrder.DescendingOrder
		)
		
		# Update table
		for row_idx, items in enumerate(rows):
			for col_idx, item in enumerate(items):
				self.albums_table.setItem(row_idx, col_idx, item)

	def update_albums_table(self, data=None):
		"""Update albums table with optional sorting."""
		df = data if data is not None else self.df
		
		# If sorting is active, sort the dataframe first
		if self.current_sort_column is not None:
			column_map = {
				0: 'Artist',
				1: 'Album',
				2: 'Release Date',
				3: 'Genre / Subgenres',
				4: 'Vocal Style',
				5: 'Country / State'
			}
			column = column_map[self.current_sort_column]
			ascending = self.sort_order == Qt.SortOrder.AscendingOrder
			
			# Create a mask for missing values
			missing_mask = df[column].isna() | df[column].astype(str).str.strip().eq('')
			
			# Split DataFrame into non-missing and missing values
			df_non_missing = df[~missing_mask]
			df_missing = df[missing_mask]
			
			# Sort non-missing values
			if column == 'Release Date':
				df_non_missing = df_non_missing.sort_values(column, ascending=ascending, key=lambda x: pd.to_datetime(x, errors='coerce'))
			else:
				df_non_missing = df_non_missing.sort_values(column, ascending=ascending, key=lambda x: x.str.lower())
			
			# Combine sorted non-missing values with missing values at the bottom
			df = pd.concat([df_non_missing, df_missing])
		
		# Update table
		self.albums_table.setRowCount(len(df))
		for i, (_, row) in enumerate(df.iterrows()):
			for col_idx, field in enumerate(['Artist', 'Album', 'Release Date', 'Genre / Subgenres', 'Vocal Style', 'Country / State']):
				value = str(row[field])
				item = QTableWidgetItem(value)
				self.albums_table.setItem(i, col_idx, item)




	def handle_tags_header_click(self, column):
		"""Handle tags table header click for sorting."""
		if column == self.tags_sort_column:
			self.tags_sort_order = Qt.SortOrder.DescendingOrder if self.tags_sort_order == Qt.SortOrder.AscendingOrder else Qt.SortOrder.AscendingOrder
		else:
			self.tags_sort_order = Qt.SortOrder.AscendingOrder
			self.tags_sort_column = column
		
		self.tags_table.sortItems(column, self.tags_sort_order)

	def update_tags_table(self):
		tag_counts = {}
		for tags in self.df['tags']:
			if isinstance(tags, list):
				for tag in tags:
					tag_counts[tag] = tag_counts.get(tag, 0) + 1
		
		self.tags_table.setSortingEnabled(False)
		self.tags_table.setRowCount(len(tag_counts))
		for i, (tag, count) in enumerate(sorted(tag_counts.items())):
			# Tag column
			tag_item = SortableTableWidgetItem(tag)
			sort_value = tag.strip().lower() if tag else chr(127)
			tag_item.setData(Qt.ItemDataRole.UserRole, sort_value)
			self.tags_table.setItem(i, 0, tag_item)
			
			# Count column
			count_item = SortableTableWidgetItem(str(count))
			count_item.setData(Qt.ItemDataRole.UserRole, f"{count:010d}")
			self.tags_table.setItem(i, 1, count_item)
		
		self.tags_table.setSortingEnabled(True)
		if self.tags_sort_column is not None:
			self.tags_table.sortItems(self.tags_sort_column, self.tags_sort_order)

	def _create_consolidation_tab(self):
		widget = QWidget()
		layout = QVBoxLayout(widget)
		
		# Tag selection area
		select_layout = QHBoxLayout()
		primary_label = QLabel("Primary Tag:")
		self.consolidation_tag_select = QComboBox()
		select_layout.addWidget(primary_label)
		select_layout.addWidget(self.consolidation_tag_select)
		layout.addLayout(select_layout)
		
		# Tags table for selection with sorting enabled
		self.consolidation_table = QTableWidget()
		self.consolidation_table.setColumnCount(2)
		self.consolidation_table.setHorizontalHeaderLabels(["Tag", "Merge"])
		self.consolidation_table.setSelectionMode(QTableWidget.SelectionMode.MultiSelection)
		self.consolidation_table.setSortingEnabled(True)
		self.consolidation_table.horizontalHeader().sectionClicked.connect(self.handle_consolidation_header_click)
		self.consolidation_sort_column = 0
		self.consolidation_sort_order = Qt.SortOrder.AscendingOrder
		layout.addWidget(self.consolidation_table)
		
		# Buttons
		button_layout = QHBoxLayout()
		self.preview_merge_button = QPushButton("Preview Merge")
		self.execute_merge_button = QPushButton("Execute Merge")
		self.preview_merge_button.clicked.connect(self.preview_tag_merge)
		self.execute_merge_button.clicked.connect(self.execute_tag_merge)
		button_layout.addWidget(self.preview_merge_button)
		button_layout.addWidget(self.execute_merge_button)
		layout.addLayout(button_layout)
		
		# Results text area
		self.merge_results = QTextEdit()
		self.merge_results.setReadOnly(True)
		layout.addWidget(self.merge_results)
		
		return widget
		
	def preview_tag_merge(self):
		primary_tag = self.consolidation_tag_select.currentText()
		if not primary_tag:
			self.merge_results.setText("Please select a primary tag")
			return
			
		selected_items = self.consolidation_table.selectedItems()
		tags_to_merge = {item.text() for item in selected_items if item.column() == 0}
		
		if not tags_to_merge:
			self.merge_results.setText("Please select tags to merge")
			return
			
		# Preview the merge using TagConsolidator
		preview = self.relationships.preview_merge(primary_tag, tags_to_merge)
		self.merge_results.setText(f"Preview of merge into '{primary_tag}':\n"
								 f"Tags to merge: {', '.join(tags_to_merge)}\n"
								 f"Affected entries: {preview.affected_count}")
		
	def execute_tag_merge(self):
		primary_tag = self.consolidation_tag_select.currentText()
		if not primary_tag:
			self.merge_results.setText("Please select a primary tag")
			return
			
		selected_items = self.consolidation_table.selectedItems()
		tags_to_merge = {item.text() for item in selected_items if item.column() == 0}
		
		if not tags_to_merge:
			self.merge_results.setText("Please select tags to merge")
			return
			
		try:
			# Execute the merge using TagConsolidator
			self.relationships.merge_tags(primary_tag, tags_to_merge)
			self.merge_results.setText(f"Successfully merged tags into '{primary_tag}'")
			# Refresh the UI
			self.update_tags_table()
			self.update_consolidation_table()
		except Exception as e:
			self.merge_results.setText(f"Error during merge: {str(e)}")
			
	def handle_consolidation_header_click(self, column):
		"""Handle consolidation table header click for sorting."""
		if column == self.consolidation_sort_column:
			self.consolidation_sort_order = Qt.SortOrder.DescendingOrder if self.consolidation_sort_order == Qt.SortOrder.AscendingOrder else Qt.SortOrder.AscendingOrder
		else:
			self.consolidation_sort_order = Qt.SortOrder.AscendingOrder
			self.consolidation_sort_column = column
		
		self.consolidation_table.sortItems(column, self.consolidation_sort_order)

	def update_consolidation_table(self):
		self.consolidation_table.setSortingEnabled(False)
		self.consolidation_table.setRowCount(len(self.all_tags))
		for i, tag in enumerate(sorted(self.all_tags)):
			# Tag column
			tag_item = SortableTableWidgetItem(tag)
			sort_value = tag.strip().lower() if tag else chr(127)
			tag_item.setData(Qt.ItemDataRole.UserRole, sort_value)
			self.consolidation_table.setItem(i, 0, tag_item)
			
			# Merge column
			merge_item = SortableTableWidgetItem("")
			merge_item.setData(Qt.ItemDataRole.UserRole, chr(127))
			self.consolidation_table.setItem(i, 1, merge_item)
		
		self.consolidation_table.setSortingEnabled(True)
		if self.consolidation_sort_column is not None:
			self.consolidation_table.sortItems(self.consolidation_sort_column, self.consolidation_sort_order)

	def handle_relationships_header_click(self, column):
		"""Handle relationships table header click for sorting."""
		if column == self.relationships_sort_column:
			self.relationships_sort_order = Qt.SortOrder.DescendingOrder if self.relationships_sort_order == Qt.SortOrder.AscendingOrder else Qt.SortOrder.AscendingOrder
		else:
			self.relationships_sort_order = Qt.SortOrder.AscendingOrder
			self.relationships_sort_column = column
		
		self.relationships_table.sortItems(column, self.relationships_sort_order)

	def update_relationships(self, tag):
		if not tag:
			return
		
		normalized = self.normalizer.normalize(tag)
		related = self.relationships.get_related_tags(normalized)
		
		self.relationships_table.setSortingEnabled(False)
		self.relationships_table.setRowCount(len(related))
		for i, (related_tag, weight) in enumerate(related):
			# Tag column
			tag_item = SortableTableWidgetItem(related_tag)
			sort_value = related_tag.strip().lower() if related_tag else chr(127)
			tag_item.setData(Qt.ItemDataRole.UserRole, sort_value)
			self.relationships_table.setItem(i, 0, tag_item)
			
			# Weight column
			weight_item = SortableTableWidgetItem(str(weight))
			weight_item.setData(Qt.ItemDataRole.UserRole, f"{weight:010.5f}")
			self.relationships_table.setItem(i, 1, weight_item)
		
		self.relationships_table.setSortingEnabled(True)
		if self.relationships_sort_column is not None:
			self.relationships_table.sortItems(self.relationships_sort_column, self.relationships_sort_order)